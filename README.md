Practice 1: Самостоятельно изучите принцип подстановки Лисков и приведите пример его использования.
Принцип подстановки Лискова (LSP) - это концепция в объектно- ориентированном программировании, которая гласит:
Функции, использующие указатели или ссылки на базовые классы, должны уметь использовать объекты производных классов, не зная об этом.
-------------------------------------------------------------------------------------------------------------------------
Practice 2: Напишите программу, которая просит ввести имя и выводит на консоль строку "Привет, <введенное имя>".
--------------------------------------------------------------------------------------------------------------------------
Practice 3: Приведите примеры для всех типов данных. Примеры должны также включать нулевые значения.
--------------------------------------------------------------------------------------------------------------------------
Practice 4: Напечатайте в консоли свое имя, используя при этом символы в формате Unicode ('\uXXXX').
--------------------------------------------------------------------------------------------------------------------------
Practice 5: Какое значение будет в переменной c после выполнения данного кода?
--------------------------------------------------------------------------------------------------------------------------
int a = 1;
{
    int b = 2;
}
int c = a + b;
Объясните полученный результат.
--------------------------------------------------------------------------------------------------------------------------
Practice 6: Приведите пример использования перегруженного оператора + с объектами типа String и переменными принадлежащим другим типам (объектам и базовым типам).
--------------------------------------------------------------------------------------------------------------------------
Practice 7: Приведите примеры, когда арифметические операции выполняются с переменными различных типов. Объясните результат.
--------------------------------------------------------------------------------------------------------------------------
Practice 8: Приведите примеры сужающего преобразования типов.
--------------------------------------------------------------------------------------------------------------------------
Practice 9: Какое значение будет в переменных b, с и d после выполнения данного кода.
--------------------------------------------------------------------------------------------------------------------------
int a = 120;
byte b = a + 10;
byte c = (byte)(a + 10);
byte d = a + 1;
Объясните полученный результат.
--------------------------------------------------------------------------------------------------------------------------
Practice 10: Самостоятельно изучите, что означает type interface и приведите пример с использование var.
--------------------------------------------------------------------------------------------------------------------------
Practice 11: Изучите утилиту javadoc и научитесь ее пользоваться.
--------------------------------------------------------------------------------------------------------------------------
Practice 12: Приведите примеры использования всех определенных выше операторов с операндами базовых типов, а также с операндами типа String. Для операторов ++ и -- продемонстрируйте префиксную и постфиксную форму записи.
--------------------------------------------------------------------------------------------------------------------------
Practice 13: Приведите примеры использования оператора instanceof. Отдельно рассмотрите случай, когда оператор применятся к null-объекту.
----------------------------------------------------------------------------------------------------------------------------
Practice 14: Приведите примеры использования методы decode().
------------------------------------------------------------------------------------------------------------------------
Practice 15: Приведите все способы создания экземпляра класса Boolean.
------------------------------------------------------------------------------------------------------------------------
Practice 16: В каком случае при автоупаковке/автораспаковке будет брошено исключение NullPointerException. Приведите пример.
------------------------------------------------------------------------------------------------------------------------
Practice 17: Какие значения напечатает следующий код?
------------------------------------------------------------------------------------------------------------------------
int i1 = 128;
Integer a1 = i1;
Integer b1 = i1;
System.out.println("a1==i1 " + (a1 == i1));
System.out.println("b1==i1 " + (b1 == i1));
System.out.println("a1==b1 " + (a1 == b1));
System.out.println("a1.equals(i1) -> " + a1.equals(i1));
System.out.println("b1.equals(i1) -> " + b1.equals(i1));
System.out.println("a1.equals(b1) -> " + a1.equals(b1));

int i2 = 127;
Integer a2 = i2;
Integer b2 = i2;
System.out.println("a2==i2 " + (a2 == i2));
System.out.println("b2==i2 " + (b2 == i2));
System.out.println("a2==b2 " + (a2 == b2));
System.out.println("a2.equals(i2) -> " + a2.equals(i2));
System.out.println("b2.equals(i2) -> " + b2.equals(i2));
System.out.println("a2.equals(b2) -> " + a2.equals(b2));

Объясните полученный результат. Для чего используется класс IntegerCache?
--------------------------------------------------------------------------------------------------------------------------
Practice 18: Запишите следующий код через конструкцию ? :
--------------------------------------------------------------------------------------------------------------------------

int i = 0;
if (a == 1) {
    i = 1;
} else if (a == 2) {
    i = 2;
} else {
    i = 3; 
}

--------------------------------------------------------------------------------------------------------------------------
Practice 19: Какого типа может быть переменная в switch? Приведите примеры для всех возможных случаев.
--------------------------------------------------------------------------------------------------------------------------
Practice 20: Что произойдет, если в некоторых частях case будет отсутствовать break, как в следующем примере?
--------------------------------------------------------------------------------------------------------------------------

...
case 1:
    i = 1;
    break;
case 2:
    i = 2;
case 3:
    i = 3;
    break;
...

--------------------------------------------------------------------------------------------------------------------------
Practice 21: Приведите тривиальные примеры бесконечных циклов для конструкций while и do-while.
--------------------------------------------------------------------------------------------------------------------------
Practice 22: Приведите пример использования операторов break и continue с любым видом цикла.
--------------------------------------------------------------------------------------------------------------------------
Practice 23: Что произойдет в результате выполнения следующего кода?
--------------------------------------------------------------------------------------------------------------------------

int a1[] = {1,2,3,4,5};
int a2[] = {6,7,8,9,10};
a1 = a2;

Practice 24: Самостоятельно изучите класс java.util.Array и приведите пример использования следующих методов:
--------------------------------------------------------------------------------------------------------------------------

String toString(...)
int binarySearch(...)
boolean equals(...)
boolean compare(...)
void sort(...)

--------------------------------------------------------------------------------------------------------------------------
Practice 25: Самостоятельно изучите смысл каждого спецификатор доступа и приведите пример программы, демонстрирующей это. Не забудьте про случай, когда спецификатор доступа отсутствует.
--------------------------------------------------------------------------------------------------------------------------
Practice 26: Приведите примеры использования перегрузки и переопределения методов.
--------------------------------------------------------------------------------------------------------------------------
Practice 27: Приведите все варианты вызова метода printVars()
--------------------------------------------------------------------------------------------------------------------------

public class A {
    public static int a = 1;
    public static int b;

    public static void printVars() {
        System.out.println(a);
        System.out.println(b);
    }
}

--------------------------------------------------------------------------------------------------------------------------
Practice 28: 
Как можно проинициализировать константу, которая объявлена следующим образом? Приведите все возможные варианты.
--------------------------------------------------------------------------------------------------------------------------

public class A {
    public final int a;
}

--------------------------------------------------------------------------------------------------------------------------
Practice 29: Что выведет данный код и почему?
--------------------------------------------------------------------------------------------------------------------------
public class A {
    {
        System.out.println("logic (1) id= " + this.id);
    }

    static {
        System.out.println("static logic");
    }

    private int id = 1;

    public A(int id) {
        this.id = id;
        System.out.println("ctor id= " + id);
    }

    {
        System.out.println("logic (2) id= " + id);
    }
}

public class Main {
    public static void main(String[] args) {
        new A(100);
    }
}

--------------------------------------------------------------------------------------------------------------------------
Practice 30: Объясните, почему в цикле for (1) будут другие результаты, чем в следующих затем вызовах (2), хотя аргументы одинаковые?
--------------------------------------------------------------------------------------------------------------------------
public class A {
    public void printNum(Integer i)
    {
        System.out.printf("Integer = %d%n", i);
    }
    public void printNum(int i)
    {
        System.out.printf("int = %d%n", i);
    }
    public void printNum(Float f)
    {
        System.out.printf("Float = %.4f%n", f);
    }
    public void printNum(Number n)
    {
        System.out.println("Number=" + n);
    }
}


public class Main {
    public static void main(String[] args) {
        A a = new A();
        Number[ ] num = {new Integer(1), 11, 1.11f, 11.11 };
        // цикл for (1)
        for (Number n : num) {
            a.printNum(n);
        }
        // (2)
        a.printNum(new Integer(1));
        a.printNum(11);
        a.printNum(1.11f);
        a.printNum(11.11);
    }
}

--------------------------------------------------------------------------------------------------------------------------
Practice 31: Приведите примеры класса, в котором перегружен метод с переменным числом параметров.
--------------------------------------------------------------------------------------------------------------------------
Practice 32: Приведите примеры класса, в котором используется инициализация элементов перечисления.
--------------------------------------------------------------------------------------------------------------------------
Practice 33: Приведите примеры реализации собственного перечисления c любым дополнительным методом.
--------------------------------------------------------------------------------------------------------------------------
Practice 34: Объясните, как нужно использовать ключевые слова this и super в подклассах?
--------------------------------------------------------------------------------------------------------------------------
Practice 35: Объясните как спецификаторы private, protected, public и спецификатор по умолчанию, меняются при наследовании на следующем примере.
--------------------------------------------------------------------------------------------------------------------------
class A {
  int a1;
  public int a2;
  protected int a3;
  private int a4;

  void method1() {
    ...
  }

  public void method2() {
    ...
  }

  protected void method3() {
    ...
  }
  
  private void method4() {
    ...
  }

}

class B extends A {
  ...
}

class C extends B {
  ...
}

--------------------------------------------------------------------------------------------------------------------------
Practice 36: Приведите пример кода, демонстрирующего невозможность переопределять в подклассе final-метод суперкласса.
--------------------------------------------------------------------------------------------------------------------------
Practice 37: Приведите пример кода, демонстрирующего невозможность использовать наследование для final-класса.
--------------------------------------------------------------------------------------------------------------------------
Practice 38: Приведите пример кода, демонстрирующего все три варианта использования ключевого слова super.
--------------------------------------------------------------------------------------------------------------------------
Practice 39: Что случится при вызове метода method() объекта класса C, если переменная a и метод method() не будут определены в классе B, а будут определены только в классе A?
--------------------------------------------------------------------------------------------------------------------------
class A {
  int a;
  void method() {
    ...
  }

}

class B extends A {
  ...
}

class C extends B {
  ...
  void method() {
    ...
    int a = super.a;
    super.method();
  }
  ...
}

--------------------------------------------------------------------------------------------------------------------------
Practice 40: Перепешите следующий код с использованием конструкции this(). Помните, что в каждом конструкторе вызов this() должен быть единственным и первым среди всех операций.
--------------------------------------------------------------------------------------------------------------------------
class A {
  int a;
  int b;
  int c;
  int z;

  public A() {
    z = 1;
  }

  public A(int a) {
    this.a = a;
    z = 1;
  }

  public A(int a, int b) {
    this.a = a;
    this.b = b;
    z = 1;
  }

  public A(int a, int b, int c) {
    this.a = a;
    this.b = b;
    this.c = c;
    z = 1;
  }
  ...
}

--------------------------------------------------------------------------------------------------------------------------
Practice 41: Приведите пример перегруженных методов.
--------------------------------------------------------------------------------------------------------------------------
Practice 42: Приведите пример переопределенного метода. Что будет, если у переопределенного и переопределяемого (из суперкласса) методов не будет совпадать тип возвращаемого значения?
--------------------------------------------------------------------------------------------------------------------------
Practice 43: Приведите пример и объясните, когда использование аннотации @Override помогает обнаружить ошибку.
--------------------------------------------------------------------------------------------------------------------------
Practice 44: Почему динамический полиморфизм не может быть применен к статическим методам?
--------------------------------------------------------------------------------------------------------------------------
Practice 45: Самостоятельно придумайте класс и переопределите для него метод equals(). Каким соглашениям должна следовать реализация этого метода?
--------------------------------------------------------------------------------------------------------------------------
Practice 46: Объясните, какая область видимости у интерфейса, объявленного следующим образом.

interface Interface {
  ...
}
--------------------------------------------------------------------------------------------------------------------------
Practice 47: Объясните, какая область видимости у интерфейса, объявленного следующим образом.

public interface Interface {
  ...
}
--------------------------------------------------------------------------------------------------------------------------
Practice 48: Объясните, какая область видимости у интерфейса, объявленного следующим образом.

protected interface Interface {
  ...
}
--------------------------------------------------------------------------------------------------------------------------
Practice 49: Объясните, какая область видимости у интерфейса, объявленного следующим образом.

private interface Interface {
  ...
}
--------------------------------------------------------------------------------------------------------------------------
Practice 50: Приведите пример интерфейса, в котором определен один неабстрактный метод и один статический метод, а также класс, реализующий этот интерфейс. Покажите все способы вызова методов интерфейса.
--------------------------------------------------------------------------------------------------------------------------
Practice 51: Что произойдет, если класс реализует два интерфейса с одинаковыми неабстрактными методами? Как выйти из такого положения? Приведите пример.
--------------------------------------------------------------------------------------------------------------------------
Practice 52: Напишите программу, в которой будет продемонстрирована функциональность десяти любых методов класса String. В комментариях к программе напишите пояснение к используемым методам.
--------------------------------------------------------------------------------------------------------------------------
Practice 53: Приведите примеры использования класса StringJoiner.
--------------------------------------------------------------------------------------------------------------------------
Practice 54: Зачем нужны три двойные кавычки?
--------------------------------------------------------------------------------------------------------------------------
Practice 55: Напишите программу, в которой будет продемонстрирована функциональность десяти любых методов классов StringBuffer и StringBuilder. В комментариях к программе напишите пояснение к используемым методам.
--------------------------------------------------------------------------------------------------------------------------
Practice 56: Покажите с помощью каких методов объекты классов String, StringBuffer и StringBuilder могут быть преобразованы друг в друга.
--------------------------------------------------------------------------------------------------------------------------
Practice 57: Приведите пример использования пяти любых спецификаторов из таблицы.
--------------------------------------------------------------------------------------------------------------------------
Practice 58: Зачем нужен метод flush()?
--------------------------------------------------------------------------------------------------------------------------
Practice 59: Приведите пример использования пяти любых спецификаторов из таблицы.
--------------------------------------------------------------------------------------------------------------------------
Practice 60: Объясните для каких целей используются основные классы исключений.
--------------------------------------------------------------------------------------------------------------------------
Practice 61: Приведите примеры кода, в которых генерируются и обрабатываются следующие исключения.
--------------------------------------------------------------------------------------------------------------------------
ArithmeticException
ArrayIndexOutOfBoundsException
IllegalArgumentException
ClassCastException
NullPointerException

--------------------------------------------------------------------------------------------------------------------------
Practice 62: Приведите пример кода с генерацией двух исключений, одно из которых будет "перхвачено", а другое приведет к аварийной остановке.
--------------------------------------------------------------------------------------------------------------------------
Practice 63: Приведите пример кода, в котором продемонстрированы следующие ситуации:
несколько исключений обрабатываются абсолютно идентичным образом;
исключения, которые обрабатываются, образуют иерархию Ex1 <|-- Ex2 <|-- Ex3, т.е. Ex3 - подкласс Ex2, а Ex2 - подкласс Ex1.

--------------------------------------------------------------------------------------------------------------------------
Practice 64: Что означает использование final при в данном объявлении?

try {
   ...
} catch (final Exception e) {
   ...
}
--------------------------------------------------------------------------------------------------------------------------
Practice 65: Приведите пример собственного класса исключения.
--------------------------------------------------------------------------------------------------------------------------
Practice 66: Можно ли использовать следующую конструкцию (try без catch и finally):

try {
  ...
}
--------------------------------------------------------------------------------------------------------------------------
Practice 67: Можно ли использовать следующую конструкцию (try только с finally):

try {
  ...
} finally {
  ...
}
--------------------------------------------------------------------------------------------------------------------------
Practice 68: Можно ли использовать следующую конструкцию (try с двумя finally):

try {
  ...
} finally {
  ...
} finally {
  ...
}
--------------------------------------------------------------------------------------------------------------------------
Practice 69: Что произойдет при выполнении данного кода? Поясните.

public class App {
  final static int START_COUNTER;
  static {
    START_COUNTER = Integer.parseInt("Y-");
  }
  public static void main(String[] args) {
    System.out.println("Hello");
  }
}
--------------------------------------------------------------------------------------------------------------------------
Practice 70: Приведите пример использования одного из подклассов класса InputStream для демонстрации работы метода read().
--------------------------------------------------------------------------------------------------------------------------
Practice 71: Приведите пример использования одного из подклассов класса OutputStream для демонстрации работы метода write(int).
--------------------------------------------------------------------------------------------------------------------------
Practice 72: Если есть иерархия байтовых потоков ввода-вывода, основанная на абстрактных классах InputStream и OutputStream, то зачем дополнительные иерархии, основанные на абстрактных классах Reader и Writer?
--------------------------------------------------------------------------------------------------------------------------
Practice 73: Зачем нужен интерфейс AutoCloseable? Приведите пример.
--------------------------------------------------------------------------------------------------------------------------
Practice 74: Приведите пример кода для чтение данных из текстового файла с помощью Scanner.
--------------------------------------------------------------------------------------------------------------------------




